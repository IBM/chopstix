#!/usr/bin/env sh
#
# ----------------------------------------------------------------------------
#
# Copyright 2019 IBM Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# ----------------------------------------------------------------------------
#

set -eu

die() { echo -e "$*" >&2; exit 1; }

usage() {

    echo -e ""
    echo -e "Usage: "
    echo -e "$0 [-h] [-output name] [-base-mpt mptfile] [-output-mpt mptfile] [-begin sym] [-end sym] [-indices iters] -- command"
    echo -e ""
    echo -e " This script generates a memory access trace of the " 
    echo -e " first execution of a Microprobe generated ELF binary "
    echo -e " created from an MPT generated using 'chop trace'. If "
	echo -e " a base MPT is provided, a modified MPT, with the memory "
	echo -e " access trace definition will be generated automatically."
    echo -e ""
    echo -e " -output name             Output base name (.memtrace.gz appended automatically) [default: output]"
	echo -e " -base-mpt mptfile        Base MPT file to modify"
    echo -e " -output-mpt mptfile      Output MPT fiel to generate (will contain base mpt plus the memory access trace definition)"
	echo -e ""
	echo -e " Other less common options:"
    echo -e " -begin symbol            Begin symbol of the region of interest in hex format [default: START_TEST]" 
    echo -e " -end symbol              End symbol of the region of interest in hex format [default: MPT2ELF_ENDLESS]"
    echo -e " -indices num1,num2,num3  Comma separated list of the invocations to be executed [default: 0]"
    echo -e " -h              : echo this help"
    echo -e ""

}

if [ $# -eq 0 ]; then usage; exit 1; fi;

start_sym=START_TEST
end_sym=MPT2ELF_ENDLESS
index=0
output=output

bin=__none__
base_mpt=__none__
output_mpt=__none__

while [ $# > 1 ]; do
    case $1 in
        (-h)
            usage
            exit 0
            ;;
        (-output)
            output="$2"
    		shift; shift ;;
        (-base-mpt)
            base_mpt="$2"
    		shift; shift ;;
        (-output-mpt)
            output_mpt="$2"
    		shift; shift ;;
        (-begin)
            start_sym="$2"
    		shift; shift ;;
        (-end)
            end_sym="$2"
    		shift; shift ;;
        (-indices)
            index="$2"
    		shift; shift ;;
        (--)
            bin="$2"
    		shift; 
			cmd=$*
			break
        (*)
            die "$0: error: Unknown parameter: $1"
            ;;
    esac;
	if [ $# -eq 0 ]; then break; fi;
done

output=${output}.memtrace.gz

[ "$bin" != "__none__" ] || die "$0: error: Binary not provided"

echo -e "chop-trace-mem start"
echo -e ""
echo -e "Configuration:"
echo -e ""
echo -e "\tBinary: $bin"
echo -e "\tCommand: $cmd"
echo -e "\tStart symbol: $start_sym"
echo -e "\tEnd symbol: $end_sym"
echo -e "\tExecution indices: $index"
echo -e "\tOutput trace: $output"
echo -e "\tBase MPT: $base_mpt"
echo -e "\tOutput MPT: $output_mpt"
echo -e ""

[ -x "$bin" ] || die "$0: error: Binary '$bin' not executable"
[ ! -r "$output" ] || die "$0: error: Output trace '$output' already exists"
[ "$base_mpt" = "__none__" ] || [ -r "$base_mpt" ] || die "$0: error: Base mpt '$base_mpt' not readable"
[ "$output_mpt" = "__none__" ] || [ "$base_mpt" != "__none__" ] || die "$0: error: Output MPT provided without base MPT"
[ "$base_mpt" = "__none__" ] || [ "$output_mpt" != "__none__" ] || die "$0: error: Base MPT provided without output MPT"
[ "$output_mpt" = "__none__" ] || [ ! -r "$output_mpt" ] || die "$0: error: Output mpt '$output_mpt' already exists"

echo -e "Computing addresses"
echo -e ""

start_addr=$(chop-marks "$bin" "$start_sym" | grep begin | sed "s/n /n=0x/g")        
end_addr=$(chop-marks "$bin" "$end_sym" | grep end | sed "s/d /d=0x/g")
if [ "$end_sym" = "MPT2ELF_ENDLESS" ]; then
    end_addr=$(chop-marks "$bin" "$end_sym" | grep begin | sed "s/n /n=0x/g")
fi

[ "$start_addr" != "" ] || die "$0: error: Unable to compute start addresses"
[ "$end_addr" != "" ] || die "$0: error: Unable to compute end addresses"

echo -e "\tStart addresses: $start_addr"
echo -e "\tEnd addresses: $end_addr"
echo -e ""

tmp=$(mktemp)
tmp2=$(mktemp)
cleanup() {
    rm -f "$tmp" "$tmp2" 
}
trap cleanup EXIT

echo -e "Tracing"
echo -e ""
echo -e "\t Tracing command: "
echo -e "\t\tchop-valgrind --tool=chopstix $start_addr $end_addr -indices=$index $cmd"
chop-valgrind --tool=chopstix $start_addr $end_addr -indices=$index $cmd 2> "$tmp" > "$tmp" 

echo -e "\t Processing trace ($output)"
grep "^[DI] [RW] 0x" < "$tmp" | head -n -1 > ${tmp2}
[ $(wc -l < $tmp2) -gt 0 ] || die "$0: error: not memory accesses traced. Check command or addresses and try manual generation" 
cat "$tmp2" | gzip -c > "$output"
echo -e ""

rm -f "$tmp"
if [ "$base_mpt" != "__none__" ]; then

	echo -e "Patching base MPT ($base_mpt)"
	echo -e ""
    set +e
	compress=$(file "$base_mpt"  | grep -c gzip)
    set -e
	if [ "$compress" -eq 1 ]; then
		zcat "$base_mpt" > "$output_mpt"
	else
		cat "$base_mpt" > "$output_mpt"
	fi

	echo -e "" >> "$output_mpt"
	echo -e "[TRACE]" >> "$output_mpt" 
	echo -e "roi_memory_access_trace = $(basename $output)" >> "$output_mpt"

	if [ "$compress" -eq 1 ]; then
		gzip -f9 "$output_mpt"
		output_mpt=${output_mpt}.gz
        if [ $(echo $output_mpt | grep -c "gz.gz$") -ne 0 ]; then
            output_mpt=$(echo ${output_mpt} | sed "s/.gz$//")
            mv ${output_mpt}.gz $output_mpt
        fi
	fi

	echo -e "\tNew patched MPT generated ($output_mpt)"
	echo -e ""
fi

echo -e "chop-trace-mem end"
exit 0
